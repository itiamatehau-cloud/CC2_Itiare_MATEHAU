<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CC2_Itiare_MATEHAU - RMarkdown</title>
    <style>
        /* Style global inspiré de RStudio HTML output */
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: #ffffff;
            color: #333333;
            line-height: 1.6;
            max-width: 900px;
            margin: auto;
            padding: 40px;
        }

        h1 { font-size: 2.2em; color: #2c3e50; border-bottom: 1px solid #eeeeee; padding-bottom: 10px; margin-top: 40px;}
        h2 { font-size: 1.6em; color: #2c3e50; margin-top: 30px; border-bottom: 1px solid #f8f8f8;}
        h3 { font-size: 1.2em; color: #34495e; margin-top: 25px;}

        /* Style des Blocs de Code (Chunks) */
        pre {
            background-color: #f7f7f7;
            border: 1px solid #cccccc;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: "Consolas", "Monaco", "Courier New", monospace;
            font-size: 0.9em;
            margin: 20px 0;
            display: block;
        }

        code {
            font-family: "Consolas", "Monaco", "Courier New", monospace;
        }

        /* Coloration des commentaires en vert */
        .comment {
            color: #228b22; /* Vert type RStudio */
            font-style: italic;
        }

        /* Style des sorties de console (Output) */
        .output {
            background-color: transparent;
            border: none;
            color: #555555;
            padding: 0 15px;
            margin-bottom: 20px;
            font-family: "Consolas", monospace;
            white-space: pre-wrap;
        }

        /* Images */
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #f0f0f0;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.05);
        }

        /* En-tête YAML */
        .yaml-header {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 40px;
        }
        .yaml-header h2 {
            border: none;
            margin: 0;
            font-size: 1em;
            color: #777;
            line-height: 1.8;
            font-weight: normal;
        }

        hr {
            border: 0;
            border-top: 1px solid #eee;
            margin: 20px 0;
        }
    </style>
</head>
<body>

<div class="yaml-header">
    <h1>CC2_Itiare_MATEHAU</h1>
    <hr>
    <h2>

<h1>CC2_Itiare_MATEHAU</h1>

<hr />

<h2>title: &quot;Analyse_(Oh et al., 2023)&quot;

output:

pdf_document: default

html_document: default

date: &quot;2026-01-12&quot;</h2>

<h1>INTRODUCTION</h1>

<p>Cette étude, intitulée &quot;Metagenomic characterization of the microbiomes in five different body habitats of otherwise healthy individuals with periodontal disease&quot;, a été publiée le 13 septembre 2023 dans la revue Frontiers in Cellular and Infection Microbiology. Les auteurs principaux sont Sujin Oh, Hyo-Jung Lee et Kyoung Un Park, issus de l'Université Nationale de Séoul.

Il porte sur la caractérisation des profils microbiens (taxonomiques et fonctionnels )dans cinq habitats corporels différents chez des individus atteints de maladie parodontale mais par ailleurs en bonne santé. Cette recherche vise à étudier le microbiome buccal, du sang et du tube digestif et à comprendre comment leur altération peut contribuer à des maladies parodontale comme des maladie cardio-vasculaire, l’Alzheimer et du cancer, avant même l’apparition des premiers symptômes cliniques.

Dans l’analyse effectuée avec le pipeline DADA2, l’objectif est de comparer la structure et la signature taxonomique des microbiomes systémiques.</p>

<h1>MATERIELS ET METHODES</h1>

<p>L'étude porte sur un échantillon de 10 adultes présentant une maladie parodontale. Des prélèvements ont été effectués dans cinq sites distincts, au niveau du sang, de la muqueuse buccale, de la plaque dentaire, de la salive ainsi que des selles. La méthode principale repose sur le séquençage du gène ARNr 16S via la plateforme MiSeq. L'analyse bioinformatique a utilisé QIIME2 pour la diversité et ANCOM-BC pour l'abondance différentielle.</p>

<h2>DADA2</h2>

<p>Pour analyser les données brutes de séquençage de cet article, les auteurs utilisé le pipeline DADA2. Contrairement aux méthodes traditionnelles basées sur les OTU (Unités Taxonomiques Opérationnelles), DADA2 permet de modéliser les erreurs de séquençage pour corriger les lectures et produire des ASV (Amplicons Sequence Variants). Le processus inclut le filtrage de qualité, la déduplication, la fusion des lectures &quot;paired-end&quot; et la suppression des chimères.</p>

<h2>1-PREPARATION</h2>

<h3>1-a) Il faut installer le package DADA2 afin de travailler sur les données de l'article:</h3>

<pre><code class="language-{r}">library(dada2); packageVersion(&quot;dada2&quot;)

</code></pre>

<p>[1] ‘1.28.0’</p>

<pre><code class="language-{r}"># Définir le chemin vers le dossier contenant les fichiers FASTQ après décompression.

path &lt;- &quot;~/Article_ADM&quot;



# Liste tous les fichiers présents dans ce dossier pour vérifier que les FASTQ sont présent.

list.files(path)

</code></pre>

<p>[1] &quot;ena-file-download-read_run-PRJNA489752-fastq_ftp-20260112-1450.sh&quot;

[2] &quot;SraRunTable.csv&quot;</p>

<h3>1-b)Télécharement des métadonnées.</h3>

<pre><code class="language-{r}">library(readr)

metadata&lt;- read_csv(&quot;~/Article_ADM/SraRunTable.csv&quot;)

</code></pre>

<h3>1-c)Assignation du chemin, la commande list.files(path) permet de créer un vecteur contenant les noms des fichiers fastq.</h3>

<pre><code class="language-{r}">path &lt;- &quot;~/Article_ADM&quot;

fnFs &lt;- sort(list.files(path, pattern=&quot;_1.fastq&quot;, full.names = TRUE))



# Récupérer et trier tous les fichiers FASTQ reverse.

fnRs &lt;- sort(list.files(path, pattern=&quot;_2.fastq&quot;, full.names = TRUE))



# Extraire les noms d'échantillons à partir des fichiers forward.

# Suppose que les fichiers ont le format SAMPLENAME_XXX.fastq.

sample.names &lt;- sapply(strsplit(basename(fnFs), &quot;_&quot;), `[`, 1)

</code></pre>

<h2>2-Inspecter les profils de qualité de lecture</h2>

<pre><code class="language-{r}">plotQualityProfile(fnFs[1:2])

</code></pre>

<p><img src="./000010.png" alt="Qualité Forward" /></p>

<p>Les profils Forward révèlent un séquençage de haute qualité (Q&gt;30) , malgré une baisse de la précision en fin de lecture au-delà de 230 pb, ce qui représente une baisse de la qualité au delà 260pb.</p>

<pre><code class="language-{r}">plotQualityProfile(fnRs[1:2])

</code></pre>

<p><img src="./000010%20(1).png" alt="Qualité Reverse" /></p>

<p>La figure ci-dessus indique que les reads &quot;reverse&quot; sont de moins bonne qualité en moyenne que les reads &quot;forward&quot;. Les profils Reverse révèlent, tout comme les profils Forward, un séquençage de haute qualité (Q&gt;30) , malgré une baisse de la précision aussi en fin de lecture au-delà de 230 pb.</p>

<h2>3-FILTRER ET DECOUPER</h2>

<pre><code class="language-{r}"># Définir le chemin et le nom des fichiers forward filtrés

# Les fichiers filtrés seront placés dans le sous-dossier &quot;filtered&quot; avec le suffixe &quot;_F_filt.fastq.gz&quot;.

filtFs &lt;- file.path(path, &quot;filtered&quot;, paste0(sample.names, &quot;_F_filt.fastq.gz&quot;))



# Définir le chemin et le nom des fichiers reverse filtrés

# Les fichiers filtrés seront placés dans le sous-dossier &quot;filtered&quot; avec le suffixe &quot;_R_filt.fastq.gz&quot;.

filtRs &lt;- file.path(path, &quot;filtered&quot;, paste0(sample.names, &quot;_R_filt.fastq.gz&quot;))



# Associer les noms des échantillons aux vecteurs de fichiers filtrés pour un accès plus facile.

names(filtFs) &lt;- sample.names

names(filtRs) &lt;- sample.names

</code></pre>

<pre><code class="language-{r}"># Filtrer et tronquer les fichiers FASTQ forward et reverse selon la qualité et la longueur, supprimer les lectures contenant des N ou trop d'erreurs, retirer les contaminants PhiX, compresser les fichiers filtrés, utilise le multithreading, et stocker un tableau résumant le nombre de lectures conservées et supprimées.

out &lt;- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),

maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,

compress=TRUE, multithread=FALSE)



head(out) # Affiche un aperçu du tableau des lectures conservées

</code></pre>

<p>reads.in reads.out

SRR7820324_1.fastq.gz 161427 138580

SRR7820325_1.fastq.gz 144452 122765

SRR7820326_1.fastq.gz 167665 145579

SRR7820327_1.fastq.gz 171871 146349

SRR7820328_1.fastq.gz 167836 145566

SRR7820329_1.fastq.gz 174471 152123</p>

<h2>4-APPRENTISSAGE DU TAUX D'ERREUR</h2>

<pre><code class="language-{r}"># Cette commande apprend les profils d'erreurs à partir des fichiers forward filtrés pour modéliser la probabilité d'erreurs de séquençage, en utilisant le multithreading pour accélérer le calcul.

errF &lt;- learnErrors(filtFs, multithread=FALSE)

</code></pre>

<p>132785520 total bases in 553273 reads from 4 samples will be used for learning the error rates.</p>

<pre><code class="language-{r}"># Cette commande apprend les profils d'erreurs à partir des fichiers reverse filtrés pour modéliser la probabilité d'erreurs de séquençage, en utilisant le multithreading pour accélérer le calcul.

errR &lt;- learnErrors(filtRs, multithread=FALSE)

</code></pre>

<p>111814240 total bases in 698839 reads from 5 samples will be used for learning the error rates.</p>

<pre><code class="language-{r}"># Affiche le graphique des profils d’erreurs appris pour les lectures forward afin de comparer les taux d’erreur observés et théoriques selon les scores de qualité.

plotErrors(errF, nominalQ=TRUE)

</code></pre>

<p><img src="./000010%20(2).png" alt="Plot Error" /></p>

<h2>5-INTERFERENCE DES ECHANTILLIONS</h2>

<pre><code class="language-{r}"># Appliquer l’algorithme DADA aux fichiers forward filtrés pour inférer les séquences exactes d’amplicons en corrigeant les erreurs de séquençage à partir du modèle d’erreurs appris.

dadaFs &lt;- dada(filtFs, err=errF, multithread=TRUE)

</code></pre>

<pre><code class="language-{r}"># Cette commande affiche le résultat de l’inférence DADA pour le premier échantillon afin d’examiner les séquences identifiées et leur abondance.

dadaFs[[1]]

</code></pre>

<p>dada-class: object describing DADA2 denoising results

557 sequence variants were inferred from 32734 input unique sequences.

Key parameters: OMEGA_A = 1e-40, OMEGA_C = 1e-40, BAND_SIZE = 16</p>

<pre><code class="language-{r}"># Appliquer l’algorithme DADA aux fichiers reverse filtrés pour inférer les séquences exactes d’amplicons en corrigeant les erreurs de séquençage à partir du modèle d’erreurs appris.

dadaRs &lt;- dada(filtRs, err=errR, multithread=TRUE)

</code></pre>

<h2>6-FUSION DES LECTURES APPROPRIEES</h2>

<pre><code class="language-{r}"># Fusionner les lectures forward et reverse pour chaque échantillon en alignant les régions qui se chevauchent et en éliminant les paires incohérentes.

mergers &lt;- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)

</code></pre>

<pre><code class="language-{r}"># Cette commande affiche les premières lignes du tableau de fusion du premier échantillon pour vérifier le bon appariement des lectures.

head(mergers[[1]])

</code></pre>

<h2>7-CONSTRUCTION DE LA TABLE DE SEQUENCES</h2>

<pre><code class="language-{r}"># Construire la table de séquences (Sequence Table) à partir des lectures fusionnées, où chaque ligne correspond à un échantillon et chaque colonne à une séquence unique.

seqtab &lt;- makeSequenceTable(mergers)



# Cette commande affiche les dimensions de la table (nombre d’échantillons et nombre de séquences uniques détectées).

dim(seqtab)

</code></pre>

<p>[1] 50 1215</p>

<pre><code class="language-{r}"># Cette commande affiche la distribution des longueurs des séquences inférées pour vérifier leur homogénéité et détecter d’éventuelles séquences aberrantes.

table(nchar(getSequences(seqtab)))

</code></pre>

<p>240 248 249 252 253 255 256 258 259 260 262 263 264 265 266 268 269 272 273 274 275 276

1 1 3 1 2 6 1 1 1 1 3 2 1 6 2 1 1 1 1 11 12 1

277 279 283 284 285 286 287 289 290 291 293 294 295 296 297 298 302 303 304 305 306 311

1 1 2 4 17 63 5 108 18 12 3 5 7 10 9 14 2 2 1 7 50 2

312 313 315 316 317 319 320 321 322 323 324 325 326 328 329 333 334 336 337 339 340 341

3 1 1 2 5 1 3 1 1 2 3 4 2 6 8 2 2 4 3 1 3 2

342 343 345 346 347 348 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365

4 1 3 9 4 1 5 1 4 1 5 5 7 2 8 32 3 8 10 7 4 7

366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387

17 4 29 6 12 4 6 40 6 105 22 9 33 20 40 7 99 29 22 33 20 47

388

11</p>

<h2>8-Suspenssion des chimères</h2>

<pre><code class="language-{r}"># Supprimer les séquences chimériques de la table à l’aide de la méthode de détection par consensus, en utilisant le multithreading pour accélérer le traitement.

seqtab.nochim &lt;- removeBimeraDenovo(seqtab, method=&quot;consensus&quot;, multithread=TRUE, verbose=TRUE)

</code></pre>

<p>Identified 521 bimeras out of 1215 input sequences.</p>

<pre><code class="language-{r}"># Cette commande affiche les dimensions de la table après suppression des séquences chimériques pour connaître le nombre de séquences restantes.

dim(seqtab.nochim)

</code></pre>

<p>[1] 50 694</p>

<h2>9-SUIVI DU PIPELINE</h2>

<pre><code class="language-{r}"># Calcule la proportion de séquences non chimériques par rapport au total pour évaluer la qualité du jeu de données après détection des chimères

sum(seqtab.nochim)/sum(seqtab)

</code></pre>

<p>[1] 0.6708379</p>

<pre><code class="language-{r}"># Crée un tableau de suivi récapitulant le nombre de lectures conservées à chaque étape du pipeline DADA2 (filtrage, débruitage, fusion et suppression des chimères) pour chaque échantillon

getN &lt;- function(x) sum(getUniques(x))

track &lt;- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))

# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)

colnames(track) &lt;- c(&quot;input&quot;, &quot;filtered&quot;, &quot;denoisedF&quot;, &quot;denoisedR&quot;, &quot;merged&quot;, &quot;nonchim&quot;)

rownames(track) &lt;- sample.names

head(track)

</code></pre>

<p>input filtered denoisedF denoisedR merged nonchim

SRR7820324 161427 138580 136888 137779 14 14

SRR7820325 144452 122765 119828 120995 0 0

SRR7820326 167665 145579 142329 143788 20 19

SRR7820327 171871 146349 144955 145548 15 14

SRR7820328 167836 145566 142073 144041 9 7

SRR7820329 174471 152123 148933 150382 15 11</p>

<h2>10-ATTRIBUER UNE TAXONOMIE</h2>

<pre><code class="language-{r}"># Assigne la taxonomie à chaque séquence non chimérique en utilisant la base SILVA v138, avec multithreading pour accélérer le traitement

taxa &lt;- assignTaxonomy(seqtab.nochim, &quot;silva_nr99_v138.2_toGenus_trainsetw.fa.gz&quot;, multithread=FALSE)

</code></pre>

<pre><code class="language-{r}"># Prépare un tableau de taxonomie pour affichage en supprimant les noms de séquences afin de faciliter la lecture

taxa.print &lt;- taxa # Removing sequence rownames for display only

rownames(taxa.print) &lt;- NULL

head(taxa.print)

</code></pre>

<p>Kingdom Phylum Class Order Family Genus

[1,] &quot;Eukaryota&quot; NA NA NA NA NA<br />

[2,] &quot;Eukaryota&quot; NA NA NA NA NA<br />

[3,] &quot;Eukaryota&quot; NA NA NA NA NA<br />

[4,] &quot;Eukaryota&quot; NA NA NA NA NA<br />

[5,] &quot;Eukaryota&quot; NA NA NA NA NA<br />

[6,] &quot;Eukaryota&quot; NA NA NA NA NA</p>

<h1>RESULTATS</h1>

<h2>Handoff to phyloseq</h2>

<pre><code class="language-{r}">library(phyloseq); packageVersion(&quot;phyloseq&quot;)

</code></pre>

<p>[1] ‘1.44.0’</p>

<pre><code class="language-{r}">library(Biostrings); packageVersion(&quot;Biostrings&quot;)

</code></pre>

<p>[1] ‘3.4.3’</p>

<pre><code class="language-{r}">library(ggpubr)

</code></pre>

<pre><code class="language-{r}">theme_set(theme_bw())

</code></pre>

<pre><code class="language-{r}">

ps &lt;- phyloseq(

otu_table(seqtab.nochim, taxa_are_rows=FALSE),

sample_names(metadata),

tax_table(taxa)

)

</code></pre>

<pre><code class="language-{r}">ps

</code></pre>

<p>phyloseq-class experiment-level object

otu_table() OTU Table: [ 694 taxa and 50 samples ]

tax_table() Taxonomy Table: [ 694 taxa by 6 taxonomic ranks ]</p>

<pre><code class="language-{r}">rownames(metadata) &lt;- metadata$Run

metadata$Habitat &lt;- metadata$isolation_source

sample_data(ps) &lt;- sample_data(metadata)

</code></pre>

<pre><code class="language-{r}">



alpha_meas &lt;- estimate_richness(ps, measures=&quot;Shannon&quot;)

sample_data(ps)$Shannon &lt;- alpha_meas$Shannon





sample_data(ps)$Habitat &lt;- factor(sample_data(ps)$isolation_source,

levels = c(&quot;saliva&quot;, &quot;subgingival plaque&quot;, &quot;buccal mucosa&quot;, &quot;blood&quot;, &quot;stool&quot;))





couleurs_habitat &lt;- c(

&quot;saliva&quot; = &quot;#E41A1C&quot;,

&quot;subgingival plaque&quot; = &quot;#377EB8&quot;,

&quot;buccal mucosa&quot; = &quot;#4DAF4A&quot;,

&quot;blood&quot; = &quot;#FF7F00&quot;,

&quot;stool&quot; = &quot;#984EA3&quot;

)





ggplot(as(sample_data(ps), &quot;data.frame&quot;), aes(x=Habitats, y=Shannon, fill=Habitats)) +

geom_violin(alpha=0.7) +

geom_boxplot(width=0.1, color=&quot;black&quot;, outlier.shape = NA) +

scale_fill_manual(values=couleurs_habitat) +

theme_bw() +

labs(

title = &quot;Shannon Entropie&quot;,

y = &quot;Shannon Index&quot;,

x = &quot;Habitats&quot;

) +

theme(

plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;, size = 14),

axis.text.x = element_text(angle = 45, hjust = 1, size = 10), # Évite la superposition

legend.position = &quot;right&quot;

)

</code></pre>

<p><img src="./000012.png" alt="Shannon Index" /></p>

<pre><code class="language-{r}">ggplot(as(sample_data(ps), &quot;data.frame&quot;), aes(x=Habitats, y=Observed, fill=Habitats)) +

geom_violin(alpha=0.7) +

geom_boxplot(width=0.1, outlier.shape = NA) +

scale_fill_manual(values=couleurs_habitat) +

labs(title=&quot;Caractéristiques Observées&quot;, y=&quot;Observed Features&quot;, x=&quot;Habitats&quot;) +

mon_theme

</code></pre>

<p><img src="./000012%20(1).png" alt="Observed Richness" /></p>

<p>L'analyse de la diversité alpha, mesurée par l'indice de Shannon et les caractéristiques observées, révèle que le microbiome sanguin présente les niveaux de richesse et d'équitabilité les plus élevés parmi les cinq habitats étudiés, avec des valeurs comprises entre 8 et 9. Cette diversité supérieure est statistiquement significative par rapport aux autres sites tel que les selles et la muqueuses qui affichent une diversité moindre.Ces résultats démontrent que le sang, chez les patients présentant une maladie parodontale, héberge une communauté bactérienne plus diversifiée que les niches écologiques comme l'intestin.</p>

<pre><code class="language-{r}">

ps_clean &lt;- prune_samples(sample_sums(ps) &gt; 0, ps)

ps_rel &lt;- transform_sample_counts(ps_clean, function(x) x / sum(x))

iDist &lt;- phyloseq::distance(ps_rel, method=&quot;bray&quot;)

iPCoA &lt;- ordinate(ps_rel, &quot;PCoA&quot;, distance=iDist)



couleurs_habitat &lt;- c(

&quot;saliva&quot; = &quot;#E41A1C&quot;,

&quot;subgingival plaque&quot; = &quot;#377EB8&quot;,

&quot;buccal mucosa&quot; = &quot;#4DAF4A&quot;,

&quot;stool&quot; = &quot;#984EA3&quot;,

&quot;blood&quot; = &quot;#FF7F00&quot;

)



plot_ordination(ps_rel, iPCoA, color=&quot;isolation_source&quot;) +

geom_point(size=4, alpha=0.8) +

stat_ellipse(aes(color=isolation_source), linetype = 2) +

scale_color_manual(values=couleurs_habitat) +

theme_minimal() +

labs(title=&quot;Figure 1B : Diversité Bêta (PCoA)&quot;,

subtitle=&quot;Composition des communautés par habitat&quot;,

color=&quot;Habitat&quot;)

</code></pre>

<p><img src="./000019.png" alt="Beta Diversité" /></p>

<p>L'analyse de la bêta-diversité par l'indice de Bray-Curtis révèle deux regroupements distincts : le microbiome du sang forme un groupe isolé, témoignant de compositions bactériennes uniques et spécialisées. À l'inverse, les échantillons de la bouche se regroupent, indiquant une forte similitude écologique au sein de la cavité buccale. Cette séparation claire sans chevauchement majeur entre le sang et la bouche confirme que chaque niche biologique héberge une communauté microbienne spécifique.</p>

<pre><code class="language-{r}">ps_non_empty &lt;- prune_samples(sample_sums(ps) &gt; 0, ps)

ps_phylum &lt;- tax_glom(ps_non_empty, &quot;Phylum&quot;)

ps_rel &lt;- transform_sample_counts(ps_phylum, function(x) 100 * x / sum(x))





df &lt;- psmelt(ps_rel)

df &lt;- df %&gt;%

mutate(Habitat = tolower(as.character(isolation_source))) %&gt;%

mutate(Habitat = case_when(

grepl(&quot;plaque&quot;, Habitat) ~ &quot;plaque&quot;,

grepl(&quot;mucosa&quot;, Habitat) ~ &quot;buccal mucosa&quot;,

TRUE ~ Habitat

))





df_plot &lt;- df %&gt;%

mutate(Phylum = as.character(Phylum)) %&gt;%

mutate(Phylum = ifelse(is.na(Phylum) | Phylum == &quot;&quot; | Phylum == &quot;unclassified&quot;,

&quot;Unclassified Bacteria&quot;, Phylum)) %&gt;%

group_by(Habitat, Phylum) %&gt;%

summarise(Abundance = mean(Abundance), .groups = 'drop') %&gt;%


mutate(Phylum = ifelse(Abundance &lt; 1, &quot;&lt; 1%&quot;, Phylum))





couleurs_phyla &lt;- c(

&quot;Actinomycetota&quot; = &quot;#D53E4F&quot;, &quot;Bacteroidota&quot; = &quot;#3288BD&quot;,

&quot;Cyanobacteria&quot; = &quot;#66C2A5&quot;, &quot;Campylobacterota&quot; = &quot;#9E0142&quot;,

&quot;Bacillota&quot; = &quot;#F46D43&quot;, &quot;Fusobacteriota&quot; = &quot;#FEE08B&quot;,

&quot;Patescibacteria&quot; = &quot;#946739&quot;, &quot;Pseudomonadota&quot; = &quot;#ABDDA4&quot;,

&quot;Spirochaetota&quot; = &quot;#E6F598&quot;, &quot;Unclassified Bacteria&quot; = &quot;#BCBDDC&quot;,

&quot;&lt; 1%&quot; = &quot;#7F7F7F&quot;

)





ggplot(df_plot, aes(x = Habitat, y = Abundance, fill = Phylum)) +

geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;, width = 0.75) +

scale_y_continuous(expand = c(0,0), limits = c(0, 100.1)) +

scale_fill_manual(values = couleurs_phyla) +

theme_bw() +

labs(x = &quot;Habitats&quot;, y = &quot;Relative abundance (%)&quot;, title = &quot;Figure 3 : Phylum-level composition&quot;) +

theme(

axis.text.x = element_text(angle = 45, hjust = 1, face = &quot;bold&quot;, size = 10),

panel.grid = element_blank(),

legend.position = &quot;right&quot;

)

</code></pre>

<p><img src="./000010%20(3).png" alt="Taxonomie" /></p>

<p>Le microbiome sanguin, de la muqueuse et de la salive sont dominées par les Pseudomonadota . À l'opposé, les selles présentent une composition très spécialisée, massivement dominée par les Bacteroidota et les Bacillota (Firmicutes). L’habitat de la plaque dentaire conserve une identité propre avec une présence marquée de Bacteroidota.</p>

<h1>DISCUSSION</h1>

<p>En comparant l’analyses (issues de DADA2 et Phyloseq) avec les données de l'article, l’observation d’une dynamique intéressante entre la réalité biologique et les choix méthodologiques. L'article met en avant le microbiome sanguin comme étant le plus diversifié, l’indice de Shannon obtenu semble appuyer la même conclusion. Cependant, les valeurs absolues sont légèrement plus basses. Cependant, l'absence de données pour la plaque dentaire (notée NA) pourraient provenir de paramètres de filtrage trop sévères.Lors de l'étape de raréfaction dans Phyloseq ces échantillons n'ont probablement pas atteint le seuil minimum de lecture requis et ont été automatiquement écartés.

Sur le plan de la bêta-diversité, malgré l'absence de la plaque, nos résultats confirment la séparation nette observée dans l'article. Le sang, les selles et les tissus buccaux ne se mélangent pas ; ils forment des îles microbiennes distinctes. Cela prouve que chaque zone du corps impose ses propres règles environnementales aux bactéries qui s'y installent.

Enfin, l’analyse taxonomique est très cohérente avec l'étude de référence. Cela confirme que les Pseudomonadota sont les piliers du microbiome sanguin et de la muqueuse, tandis que les Bacteroidota et les Bacillota (Firmicutes) règnent sur les selles. Cette stabilité dans les résultats, malgré des pipelines différents, renforce l'idée que ces phyla sont les véritables signatures biologiques de nos habitats corporels.</p>

<h1>CONCLUSION</h1>

<p>Cette étude a permis de confronter les profils microbiens de cinq habitats corporels chez des patients atteints de maladie parodontale. Le corps humain ne constitue pas un environnement uniforme, mais un archipel de niches écologiques hautement spécialisées.

En définitive, ce travail renforce l'idée que le microbiome systémique est un indicateur précieux de l'état de santé.</p>
